defmodule EctoCassandra.Planner do
  @moduledoc """
  Ecto Cassandra core planner
  """

  require Logger
  alias EctoCassandra.{Conn, Query, Types}
  alias Xandra.Batch

  @behaviour Ecto.Adapter

  @type t :: EctoCassandra.Adapter.Planner

  @type query_meta() :: %{
          prefix: binary() | nil,
          sources: tuple(),
          preloads: term(),
          select: map()
        }

  @type schema_meta :: %{
          source: source,
          schema: atom,
          context: term,
          autogenerate_id: {atom, :id | :binary_id}
        }

  @type query :: Ecto.Query.t()
  @type source :: {prefix :: binary | nil, table :: binary}
  @type fields :: Keyword.t()
  @type filters :: Keyword.t()
  @type constraints :: Keyword.t()
  @type returning :: [atom]
  @type prepared :: term
  @type cached :: term
  @type process :: (field :: Macro.t(), value :: term, context :: term -> term)
  @type autogenerate_id :: {field :: atom, type :: :id | :binary_id, value :: term} | nil

  @type on_conflict ::
          {:raise, list(), []}
          | {:nothing, list(), [atom]}
          | {query, list(), [atom]}

  @typep repo :: Ecto.Repo.t()
  @typep options :: Keyword.t()

  @doc false
  defmacro __before_compile__(_env), do: :ok

  @spec ensure_all_started(any, type :: Application.restart_type()) ::
          {:error, atom} | {:ok, [atom()]}
  def ensure_all_started(_repo, _type) do
    with {:ok, apps} <- Application.ensure_all_started(:db_connection) do
      {:ok, apps}
    else
      {:error, {atom, _}} -> {:error, atom}
    end
  end

  @spec child_spec(any, keyword) :: Supervisor.Spec.spec()
  def child_spec(_repo, opts) do
    keyspace = Keyword.fetch!(opts, :keyspace)

    opts =
      Keyword.merge(opts,
        name: EctoCassandra.Conn,
        after_connect: &Xandra.execute(&1, "USE #{keyspace}")
      )

    Supervisor.Spec.worker(Xandra, [opts], restart: :permanent)
  end

  @doc """
  Automatically generate next ID for binary keys, leave sequence keys empty for generation on insert.
  """
  @spec autogenerate(:binary_id | :embed_id) :: <<_::288>>
  def autogenerate(:embed_id) do
    Elixir.UUID.uuid1()
  end

  def autogenerate(:binary_id) do
    Elixir.UUID.uuid1()
  end

  def autogenerate(_) do
    raise(
      ArgumentError,
      "Cassandra adapter does not support autogenerated :id field type in schema."
    )
  end

  @spec prepare(atom :: :all | :update_all | :delete_all, query) ::
          {:cache, Xandra.Prepared.t()} | no_return
  def prepare(:all, query) do
    prepared = Xandra.prepare!(Conn, EctoCassandra.Query.all(query, []))
    {:cache, prepared}
  end

  def prepare(operation, query) do
    prepared = Xandra.prepare!(Conn, EctoCassandra.Query.new([{operation, query}]))

    {:cache, prepared}
  end

  @spec execute(repo, query_meta, query, params :: list, process | nil, options) :: result
        when result: {integer, [[term]] | nil} | no_return,
             query:
               {:nocache, prepared()}
               | {:cached, (prepared -> :ok), cached}
               | {:cache, (cached -> :ok), prepared}
  def execute(repo, query, {:nocache, prepared}, sources, preprocess, opts) do
    execute(repo, query, {:cache, nil, prepared}, sources, preprocess, opts)
  end

  def execute(
        _repo,
        %{sources: {{_table_name, schema}}},
        {:cache, _, prepared},
        sources,
        preprocess,
        _opts
      ) do
    with %Xandra.Page{} = page <- Xandra.execute!(Conn, prepared, sources) do
      process_page(page, schema, preprocess)
    else
      %Xandra.Void{} ->
        {0, []}

      err ->
        err
    end
  end

  defp process_page(page, schema, preprocess) do
    case Enum.to_list(page) do
      [%{"[applied]" => true}] ->
        {1, []}

      pages ->
        {length(pages), Enum.map(pages, &process_row(&1, preprocess, schema.__schema__(:fields)))}
    end
  end

  @spec insert(repo, schema_meta, fields, on_conflict, returning, options) ::
          {:ok, fields}
          | {:invalid, constraints}
          | no_return
  def insert(
        _repo,
        %{schema: schema, source: {_, table}},
        sources,
        _on_conflict,
        _returning,
        opts
      ),
      do: do_insert(table, schema, sources, opts)

  defp do_insert(table, schema, sources, opts) do
    statement = Query.new(insert: {table, sources, opts})
    prepared_sources = prepare_sources(schema, sources)

    with {:ok, %Xandra.Void{}} <- Xandra.execute(Conn, statement, prepared_sources) do
      {:ok, []}
    else
      {:ok, %Xandra.Page{} = page} -> check_applied(page)
      err -> err
    end
  end

  @spec insert_all(repo, schema_meta, header :: [atom], [fields], any, returning, options) ::
          {integer, [[term]] | nil}
          | no_return
  def insert_all(
        _repo,
        %{source: {_, table}, schema: schema},
        header,
        rows,
        _on_conflict,
        _returning,
        opts
      ) do
    batch_mode = Keyword.get(opts, :batch, false)

    case batch_mode in ~w(logged unlogged counter)a do
      true -> do_batch_insert_all(table, header, rows, opts)
      false -> do_insert_all(table, schema, rows, opts)
    end
  end

  defp do_batch_insert_all(table, header, rows, opts) do
    prepared = Xandra.prepare!(Conn, Query.new(insert_all: {table, header, opts}))

    batch =
      Enum.reduce(
        rows,
        Batch.new(),
        &Batch.add(&2, prepared, &1 |> Keyword.take(header) |> Keyword.values())
      )

    with %Xandra.Void{} <- Xandra.execute!(Conn, batch), do: {:ok, []}
  end

  defp do_insert_all(table, schema, rows, opts) do
    result = for row <- rows, do: do_insert(table, schema, row, opts)

    {length(result), []}
  end

  @spec update(repo, schema_meta, fields, filters, returning, options) ::
          {:ok, fields}
          | {:invalid, constraints}
          | no_return
  def update(_repo, %{source: {nil, table_name}, schema: schema}, params, filter, _gen, opts) do
    statement = Query.new(update: {table_name, params, filter, opts})
    sources = prepare_sources(schema, params)

    with {:ok, %Xandra.Void{}} <- Xandra.execute(Conn, statement, sources) do
      {:ok, []}
    else
      {:error, any} -> {:invalid, any}
    end
  end

  @spec delete(repo, schema_meta, filters, options) ::
          {:ok, fields}
          | {:invalid, constraints}
          | no_return
  def delete(_repo, %{source: {nil, table_name}}, filters, opts) do
    statement = Query.delete({table_name, filters, opts})

    with %Xandra.Void{} <- Xandra.execute!(Conn, statement) do
      {:ok, []}
    else
      {:ok, %Xandra.Page{} = page} -> check_applied(page)
      err -> {:invalid, err}
    end
  end

  @spec loaders(primitive_type :: Ecto.Type.primitive(), ecto_type :: Ecto.Type.t()) :: [
          (term -> {:ok, term} | :error) | Ecto.Type.t()
        ]
  def loaders(:binary_id, type) do
    [
      &case Ecto.UUID.cast(&1) do
        {:ok, uuid} -> {:ok, uuid}
        _ -> {:ok, &1}
      end,
      type
    ]
  end

  def loaders(type, _) when type in ~w(utc_datetime naive_datetime)a, do: [&to_dt/1]
  def loaders(_primitive, type), do: [type]

  @spec dumpers(primitive_type :: Ecto.Type.primitive(), ecto_type :: Ecto.Type.t()) :: [
          (term -> {:ok, term} | :error) | Ecto.Type.t()
        ]
  def dumpers(:binary_id, type), do: [type]

  def dumpers(datetime, _type) when datetime in [:datetime, :utc_datetime, :naive_datetime],
    do: [&to_dt/1]

  def dumpers(_primitive, type), do: [type]

  defp check_applied(page) do
    case Enum.to_list(page) do
      [%{"[applied]" => true}] -> {:ok, []}
      _ -> {:invalid, exists: "was not applied"}
    end
  end

  defp process_row(row, preprocess, fields) when is_function(preprocess),
    do: fields |> Enum.map(fn f -> Map.get(row, to_string(f)) end) |> preprocess.()

  defp process_row(row, _, fields), do: process_row(row, & &1, fields)

  defp prepare_sources(schema, sources) do
    for k <- Keyword.keys(sources), into: %{} do
      ecto_type = schema.__schema__(:type, k)
      {to_string(k), {ecto_type |> Types.to_db() |> to_string, sources[k]}}
    end
  end

  defp to_dt(%NaiveDateTime{} = dt), do: DateTime.from_naive(dt, "Etc/UTC")
  defp to_dt(%DateTime{} = dt), do: {:ok, dt}
  defp to_dt(_), do: :error
end
